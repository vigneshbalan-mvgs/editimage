<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Editor Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
      }

      #messageBox {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #333;
        color: white;
        padding: 15px 30px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        display: none;
        animation: slideIn 0.5s ease-out;
      }

      @keyframes slideIn {
        from {
          transform: translateX(-50%) translateY(100%);
        }

        to {
          transform: translateX(-50%) translateY(0);
        }
      }

      .loader-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        z-index: 500;
        transition: opacity 0.3s ease-in-out;
      }

      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: #000;
        animation: spin 1s ease infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }

      .panel {
        display: none;
        padding: 1.5rem;
        background-color: white;
        border-radius: 0.5rem;
        box-shadow:
          0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
      }

      .panel.active {
        display: block;
        animation: fadeIn 0.3s ease-in-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }

        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .checkerboard {
        background-color: #f0f0f0;
        background-image:
          linear-gradient(
            45deg,
            #ccc 25%,
            transparent 25%,
            transparent 75%,
            #ccc 75%,
            #ccc
          ),
          linear-gradient(
            45deg,
            #ccc 25%,
            transparent 25%,
            transparent 75%,
            #ccc 75%,
            #ccc
          );
        background-size: 16px 16px;
        background-position:
          0 0,
          8px 8px;
      }

      .toolbar-button {
        padding: 0.5rem 1rem;
        background-color: #d1d5db;
        /* gray-300 */
        border-radius: 0.5rem;
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        transition-property:
          background-color, border-color, color, fill, stroke, opacity,
          box-shadow, transform;
        transition-duration: 150ms;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        align-items: center;
      }

      .toolbar-button:hover:not(:disabled) {
        background-color: #9ca3af;
        /* gray-400 */
      }

      .toolbar-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .crop-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: none;
        /* Add crosshair cursor for better user experience */
        cursor: crosshair;
      }

      .crop-box {
        position: absolute;
        box-sizing: border-box;
        border: 1px solid #fff;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
        cursor: move;
        pointer-events: auto;
      }

      .crop-handle {
        position: absolute;
        width: 10px;
        height: 10px;
        background: #fff;
        border: 1px solid #333;
        pointer-events: auto;
      }

      .crop-handle.tl {
        top: -5px;
        left: -5px;
        cursor: nwse-resize;
      }

      .crop-handle.tr {
        top: -5px;
        right: -5px;
        cursor: nesw-resize;
      }

      .crop-handle.bl {
        bottom: -5px;
        left: -5px;
        cursor: nesw-resize;
      }

      .crop-handle.br {
        bottom: -5px;
        right: -5px;
        cursor: nwse-resize;
      }

      .crop-handle.t {
        top: -5px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }

      .crop-handle.b {
        bottom: -5px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }

      .crop-handle.l {
        left: -5px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }

      .crop-handle.r {
        right: -5px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }
    </style>
  </head>

  <body class="bg-gray-100 text-gray-800 font-sans h-screen flex flex-col">
    <header class="bg-gray-800 text-white shadow-lg">
      <div
        class="container mx-auto px-4 py-3 flex items-center justify-between"
      >
        <h1 class="text-xl font-bold">üñºÔ∏è Image Editor</h1>
        <!-- Top Bar Actions -->
        <div class="flex items-center space-x-2">
          <label for="fileInput" class="toolbar-button cursor-pointer">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              fill="currentColor"
              viewBox="0 0 16 16"
            >
              <path
                d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"
              />
              <path
                d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V10.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"
              />
            </svg>
            Upload
          </label>
          <input type="file" id="fileInput" accept="image/*" class="hidden" />

          <button
            id="undoButton"
            onclick="undo()"
            class="toolbar-button"
            disabled
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              fill="currentColor"
              class="bi bi-arrow-counterclockwise"
              viewBox="0 0 16 16"
            >
              <path
                fill-rule="evenodd"
                d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"
              />
              <path
                d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"
              />
            </svg>
          </button>

          <button
            id="redoButton"
            onclick="redo()"
            class="toolbar-button"
            disabled
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              fill="currentColor"
              class="bi bi-arrow-clockwise"
              viewBox="0 0 16 16"
            >
              <path
                fill-rule="evenodd"
                d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"
              />
              <path
                d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"
              />
            </svg>
          </button>

          <button onclick="resetToOriginal()" class="toolbar-button">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              fill="currentColor"
              viewBox="0 0 16 16"
            >
              <path
                d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"
              />
              <path
                fill-rule="evenodd"
                d="M8 3c-1.552 0-2.94.707-3.857 1.769-.42.451-.762.91-1.01 1.39C2.68 7.391 2 9.22 2 11c0 .818.397 1.6.861 2.292.573.844 1.47 1.45 2.457 1.815.531.192 1.09.333 1.66.426V.76L5.804 1.904a.25.25 0 0 1-.397-.2L6.38 2.052a.25.25 0 0 1 .397.2L5.804 1.904a.25.25 0 0 1-.397-.2z"
              />
            </svg>
          </button>
        </div>
      </div>
    </header>

    <div class="flex-1 flex overflow-hidden">
      <!-- Left Panel: Canvas Area -->
      <div
        id="canvas-section"
        class="flex-1 flex items-center justify-center relative p-4 overflow-auto"
        ondragover="handleDragOver(event)"
        ondrop="handleDrop(event)"
      >
        <canvas
          id="editorCanvas"
          class="max-w-full max-h-full border border-gray-400 rounded-lg shadow-lg"
        ></canvas>
        <div id="crop-overlay" class="crop-overlay">
          <div id="crop-box" class="crop-box">
            <div class="crop-handle tl"></div>
            <div class="crop-handle tr"></div>
            <div class="crop-handle bl"></div>
            <div class="crop-handle br"></div>
            <div class="crop-handle t"></div>
            <div class="crop-handle b"></div>
            <div class="crop-handle l"></div>
            <div class="crop-handle r"></div>
          </div>
        </div>
        <div id="loader" class="loader-overlay hidden">
          <div class="spinner"></div>
          <p class="mt-2 text-lg">‚è≥ Processing...</p>
        </div>
      </div>

      <!-- Right Panel: Side Bar Controls and Features -->
      <div
        class="w-full md:w-80 p-4 bg-gray-100 border-l border-gray-300 overflow-y-auto flex-shrink-0"
      >
        <div id="sidebar-toolbar" class="flex flex-col gap-2 mb-4">
          <button
            onclick="showPanel('cropPanel')"
            class="toolbar-button w-full"
          >
            Crop
          </button>
          <button
            onclick="showPanel('resizePanel')"
            class="toolbar-button w-full"
          >
            Resize
          </button>
          <button
            onclick="showPanel('removeReplacePanel')"
            class="toolbar-button w-full"
          >
            Remove & Replace
          </button>
          <button
            onclick="showPanel('exportPanel')"
            class="toolbar-button w-full"
          >
            Export
          </button>
        </div>

        <!-- Panels -->
        <div id="cropPanel" class="panel">
          <h3 class="text-xl font-semibold mb-4">Crop Image</h3>
          <p class="text-gray-600 mb-4">
            Select a crop area on the canvas and use the handles to resize.
          </p>
          <div class="grid grid-cols-2 gap-4">
            <label class="block">
              <span class="text-gray-700">X:</span>
              <input
                type="number"
                id="cropX"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
              />
            </label>
            <label class="block">
              <span class="text-gray-700">Y:</span>
              <input
                type="number"
                id="cropY"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
              />
            </label>
            <label class="block">
              <span class="text-gray-700">Width:</span>
              <input
                type="number"
                id="cropWidth"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
              />
            </label>
            <label class="block">
              <span class="text-gray-700">Height:</span>
              <input
                type="number"
                id="cropHeight"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
              />
            </label>
          </div>
          <div class="flex mt-4 gap-2">
            <button
              id="applyCropBtn"
              onclick="applyCrop()"
              class="flex-1 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
            >
              Apply Crop
            </button>
            <button
              id="cancelCropBtn"
              onclick="cancelCrop()"
              class="flex-1 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors"
            >
              Cancel Crop
            </button>
          </div>
        </div>

        <div id="resizePanel" class="panel">
          <h3 class="text-xl font-semibold mb-4">Resize Image</h3>
          <div class="grid grid-cols-2 gap-4">
            <label class="block">
              <span class="text-gray-700">Width:</span>
              <input
                type="number"
                id="resizeWidth"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                disabled
              />
            </label>
            <label class="block">
              <span class="text-gray-700">Height:</span>
              <input
                type="number"
                id="resizeHeight"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                disabled
              />
            </label>
          </div>
          <label class="flex items-center mt-4">
            <input
              type="checkbox"
              id="keepRatio"
              class="rounded text-blue-500"
              checked
              disabled
            />
            <span class="ml-2 text-gray-700">Keep Aspect Ratio</span>
          </label>
          <button
            id="resizeButton"
            onclick="applyResize()"
            disabled
            class="w-full mt-4 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
          >
            Apply Resize
          </button>
        </div>

        <div id="removeReplacePanel" class="panel">
          <h3 class="text-xl font-semibold mb-4">Remove & Replace Color</h3>
          <p class="text-gray-600 mb-4">
            Click on the canvas to pick a color to remove.
          </p>
          <label class="block mb-4">
            <span class="text-gray-700">Color to Remove:</span>
            <input
              type="color"
              id="removeColorPicker"
              value="#ffffff"
              class="mt-1"
            />
          </label>
          <label class="flex items-center mb-4">
            <input
              type="checkbox"
              id="replaceEnabled"
              class="rounded text-blue-500"
              checked
            />
            <span class="ml-2 text-gray-700">Replace with New Color</span>
          </label>
          <label class="block mb-2" id="newBgColorLabel">
            <span class="text-gray-700">Replacement Color:</span>
            <input
              type="color"
              id="newBgColorPicker"
              value="#000000"
              class="mt-1"
            />
          </label>
          <label class="block mb-4">
            <span class="text-gray-700">Tolerance:</span>
            <input
              type="range"
              id="removeColorTolerance"
              value="40"
              min="0"
              max="255"
              step="1"
              class="mt-1 w-full"
            />
          </label>
          <button
            onclick="removeAndReplaceColor()"
            class="w-full px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
          >
            Apply
          </button>
        </div>

        <div id="exportPanel" class="panel">
          <h3 class="text-xl font-semibold mb-4">Export Image</h3>
          <label class="block mb-2">
            <span class="text-gray-700">Filename:</span>
            <input
              type="text"
              id="exportName"
              placeholder="filename"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
            />
          </label>
          <label class="block mb-2">
            <span class="text-gray-700">Format:</span>
            <select
              id="exportFormat"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
            >
              <option value="png">PNG</option>
              <option value="jpeg">JPEG</option>
              <option value="webp">WebP</option>
            </select>
          </label>
          <label class="block mb-4">
            <span class="text-gray-700">Quality:</span>
            <input
              type="range"
              id="exportQuality"
              min="0.1"
              max="1.0"
              step="0.1"
              value="1.0"
              class="mt-1 w-full"
            />
          </label>
          <button
            onclick="exportImage()"
            class="w-full px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
          >
            Export Image
          </button>

          <h3 class="text-xl font-semibold mt-6 mb-4">Export to PDF</h3>
          <label class="block mb-2">
            <span class="text-gray-700">Filename:</span>
            <input
              type="text"
              id="pdfName"
              placeholder="filename.pdf"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
            />
          </label>
          <button
            onclick="downloadPDF()"
            class="w-full px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
          >
            Export to PDF
          </button>
        </div>
      </div>
    </div>

    <!-- Custom Message Box -->
    <div id="messageBox"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
      let canvas = document.getElementById("editorCanvas");
      let ctx = canvas.getContext("2d");
      let originalImg = null;
      let originalImageData = null;
      let keepRatioCheckbox = document.getElementById("keepRatio");
      let canvasSection = document.getElementById("canvas-section");
      let replaceEnabledCheckbox = document.getElementById("replaceEnabled");
      let newBgColorPicker = document.getElementById("newBgColorPicker");

      // History for undo/redo
      let history = [];
      let historyIndex = -1;
      const MAX_HISTORY_STEPS = 20;

      // Get undo/redo buttons
      const undoButton = document.getElementById("undoButton");
      const redoButton = document.getElementById("redoButton");
      const fileInput = document.getElementById("fileInput");

      // Crop functionality elements
      const cropOverlay = document.getElementById("crop-overlay");
      const cropBox = document.getElementById("crop-box");
      const cropXInput = document.getElementById("cropX");
      const cropYInput = document.getElementById("cropY");
      const cropWidthInput = document.getElementById("cropWidth");
      const cropHeightInput = document.getElementById("cropHeight");
      let isCropping = false;
      let isDragging = false;
      let isResizing = false;
      let dragStartX, dragStartY;
      let resizeHandle = null;

      // Set a default size and message for an empty canvas
      function setInitialCanvasState() {
        const containerWidth = canvasSection.offsetWidth;
        canvas.width = Math.min(800, containerWidth - 40);
        canvas.height = Math.min(600, containerWidth * 0.75);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#666";
        ctx.font = "24px Inter";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(
          "Drop an image here or use the Upload button",
          canvas.width / 2,
          canvas.height / 2,
        );
      }
      setInitialCanvasState();

      let initialImageData = null;

      window.addEventListener("resize", () => {
        if (!originalImg) {
          setInitialCanvasState();
        }
        // Re-position crop overlay if window is resized while cropping
        if (isCropping) {
          updateCropOverlayPosition();
        }
      });

      // Event listener for the "Replace with New Color" checkbox
      replaceEnabledCheckbox.addEventListener("change", function () {
        newBgColorPicker.disabled = !this.checked;
      });

      // --- History Functions ---
      function saveHistory() {
        // Remove any steps that have been undone before adding a new one
        if (historyIndex < history.length - 1) {
          history = history.slice(0, historyIndex + 1);
        }

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        history.push(imageData);
        if (history.length > MAX_HISTORY_STEPS) {
          history.shift(); // Remove the oldest state
        } else {
          historyIndex++;
        }
        updateUndoRedoButtons();
      }

      function undo() {
        if (historyIndex > 0) {
          historyIndex--;
          const imageData = history[historyIndex];
          canvas.width = imageData.width;
          canvas.height = imageData.height;
          ctx.putImageData(imageData, 0, 0);
          updateUndoRedoButtons();
        }
      }

      function redo() {
        if (historyIndex < history.length - 1) {
          historyIndex++;
          const imageData = history[historyIndex];
          canvas.width = imageData.width;
          canvas.height = imageData.height;
          ctx.putImageData(imageData, 0, 0);
          updateUndoRedoButtons();
        }
      }

      function updateUndoRedoButtons() {
        undoButton.disabled = historyIndex <= 0;
        redoButton.disabled = historyIndex >= history.length - 1;
      }

      function showMessage(message, duration = 3000) {
        const msgBox = document.getElementById("messageBox");
        msgBox.textContent = message;
        msgBox.style.display = "block";
        setTimeout(() => {
          msgBox.style.display = "none";
        }, duration);
      }

      function showPanel(id) {
        if (isCropping) {
          cancelCrop();
        }

        document
          .querySelectorAll(".panel")
          .forEach((p) => p.classList.remove("active"));
        document.getElementById(id).classList.add("active");

        document
          .querySelectorAll("#sidebar-toolbar button")
          .forEach((btn) => btn.classList.remove("active"));
        const activeBtn = document.querySelector(
          `#sidebar-toolbar button[onclick="showPanel('${id}')"]`,
        );
        if (activeBtn) activeBtn.classList.add("active");

        if (id === "cropPanel" && originalImg) {
          startCrop();
        }
      }

      function showLoader(show = true, message = "Processing...") {
        const loader = document.getElementById("loader");
        loader.querySelector("p").textContent = message;
        loader.style.display = show ? "flex" : "none";
      }

      function setCheckerboard(enabled) {
        if (enabled) {
          canvasSection.classList.add("checkerboard");
        } else {
          canvasSection.classList.remove("checkerboard");
        }
      }

      fileInput.addEventListener("change", function (e) {
        const file = e.target.files[0];
        if (!file) return;
        showLoader(true);
        const img = new Image();
        const reader = new FileReader();
        reader.onload = function (event) {
          img.onload = function () {
            if (file.type === "image/png" || file.type === "image/webp") {
              setCheckerboard(true);
            } else {
              setCheckerboard(false);
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            originalImg = img;

            // Clear and save initial state to history
            history = [];
            historyIndex = -1;
            saveHistory();

            initialImageData = ctx.getImageData(
              0,
              0,
              canvas.width,
              canvas.height,
            );
            document.getElementById("resizeWidth").disabled = false;
            document.getElementById("resizeHeight").disabled = false;
            document.getElementById("keepRatio").disabled = false;
            document.getElementById("resizeButton").disabled = false;

            document.getElementById("resizeWidth").value = img.width;
            document.getElementById("resizeHeight").value = img.height;
            showLoader(false);
            showMessage("Image loaded successfully!");
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });

      // --- New Crop Functionality ---
      function updateCropOverlayPosition() {
        // This function ensures the overlay is perfectly aligned with the canvas element.
        const canvasRect = canvas.getBoundingClientRect();
        const parentRect = canvasSection.getBoundingClientRect();
        cropOverlay.style.left = `${canvasRect.left - parentRect.left}px`;
        cropOverlay.style.top = `${canvasRect.top - parentRect.top}px`;
        cropOverlay.style.width = `${canvasRect.width}px`;
        cropOverlay.style.height = `${canvasRect.height}px`;
      }

      function startCrop() {
        if (!originalImg) {
          showMessage("Please upload an image first.");
          return;
        }
        isCropping = true;
        cropOverlay.style.display = "block";

        // Position the crop overlay correctly relative to the canvas.
        updateCropOverlayPosition();

        const canvasRect = canvas.getBoundingClientRect();
        const minDimension = Math.min(canvasRect.width, canvasRect.height);
        const initialCropSize = minDimension * 0.75;
        cropBox.style.width = `${initialCropSize}px`;
        cropBox.style.height = `${initialCropSize}px`;
        cropBox.style.left = `${(canvasRect.width - initialCropSize) / 2}px`;
        cropBox.style.top = `${(canvasRect.height - initialCropSize) / 2}px`;

        updateCropInputs();

        cropBox.addEventListener("mousedown", startDrag);
        cropBox.querySelectorAll(".crop-handle").forEach((handle) => {
          handle.addEventListener("mousedown", startResize);
        });
        document.addEventListener("mousemove", dragOrResize);
        document.addEventListener("mouseup", endDragOrResize);

        cropXInput.addEventListener("input", updateCropBoxFromInputs);
        cropYInput.addEventListener("input", updateCropBoxFromInputs);
        cropWidthInput.addEventListener("input", updateCropBoxFromInputs);
        cropHeightInput.addEventListener("input", updateCropBoxFromInputs);
      }

      function cancelCrop() {
        if (!isCropping) return;
        isCropping = false;
        cropOverlay.style.display = "none";
        cropBox.removeEventListener("mousedown", startDrag);
        cropBox.querySelectorAll(".crop-handle").forEach((handle) => {
          handle.removeEventListener("mousedown", startResize);
        });
        document.removeEventListener("mousemove", dragOrResize);
        document.removeEventListener("mouseup", endDragOrResize);

        cropXInput.removeEventListener("input", updateCropBoxFromInputs);
        cropYInput.removeEventListener("input", updateCropBoxFromInputs);
        cropWidthInput.removeEventListener("input", updateCropBoxFromInputs);
        cropHeightInput.removeEventListener("input", updateCropBoxFromInputs);

        showMessage("Crop cancelled.");
      }

      function startDrag(e) {
        e.preventDefault();
        if (!isCropping) return;
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
      }

      function startResize(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!isCropping) return;
        isResizing = true;
        resizeHandle = e.target;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
      }

      function dragOrResize(e) {
        if (!isDragging && !isResizing) return;
        e.preventDefault();

        const canvasRect = canvas.getBoundingClientRect();
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;

        let newLeft = cropBox.offsetLeft;
        let newTop = cropBox.offsetTop;
        let newWidth = cropBox.offsetWidth;
        let newHeight = cropBox.offsetHeight;

        if (isDragging) {
          newLeft += dx;
          newTop += dy;
        } else if (isResizing) {
          const minSize = 20;
          switch (resizeHandle.className) {
            case "crop-handle tl":
              newWidth -= dx;
              newHeight -= dy;
              newLeft += dx;
              newTop += dy;
              break;
            case "crop-handle tr":
              newWidth += dx;
              newHeight -= dy;
              newTop += dy;
              break;
            case "crop-handle bl":
              newWidth -= dx;
              newHeight += dy;
              newLeft += dx;
              break;
            case "crop-handle br":
              newWidth += dx;
              newHeight += dy;
              break;
            case "crop-handle t":
              newHeight -= dy;
              newTop += dy;
              break;
            case "crop-handle b":
              newHeight += dy;
              break;
            case "crop-handle l":
              newWidth -= dx;
              newLeft += dx;
              break;
            case "crop-handle r":
              newWidth += dx;
              break;
          }

          // Ensure minimum size and boundary constraints
          newWidth = Math.max(minSize, newWidth);
          newHeight = Math.max(minSize, newHeight);
          newLeft = Math.max(0, newLeft);
          newTop = Math.max(0, newTop);

          newWidth = Math.min(newWidth, canvasRect.width - newLeft);
          newHeight = Math.min(newHeight, canvasRect.height - newTop);
        }

        // Update position and size
        cropBox.style.left = `${newLeft}px`;
        cropBox.style.top = `${newTop}px`;
        cropBox.style.width = `${newWidth}px`;
        cropBox.style.height = `${newHeight}px`;

        dragStartX = e.clientX;
        dragStartY = e.clientY;
      }

      function endDragOrResize() {
        isDragging = false;
        isResizing = false;
        resizeHandle = null;
        // Update the input fields only after the drag/resize is finished.
        updateCropInputs();
      }

      function updateCropInputs() {
        const canvasRect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / canvasRect.width;
        const scaleY = canvas.height / canvasRect.height;

        const x = Math.round(cropBox.offsetLeft * scaleX);
        const y = Math.round(cropBox.offsetTop * scaleY);
        const width = Math.round(cropBox.offsetWidth * scaleX);
        const height = Math.round(cropBox.offsetHeight * scaleY);

        cropXInput.value = x;
        cropYInput.value = y;
        cropWidthInput.value = width;
        cropHeightInput.value = height;
      }

      function updateCropBoxFromInputs() {
        if (!isCropping) return;
        const canvasRect = canvas.getBoundingClientRect();
        const scaleX = canvasRect.width / canvas.width;
        const scaleY = canvasRect.height / canvas.height;

        let x = parseInt(cropXInput.value) || 0;
        let y = parseInt(cropYInput.value) || 0;
        let width = parseInt(cropWidthInput.value) || 0;
        let height = parseInt(cropHeightInput.value) || 0;

        // Boundary constraints
        x = Math.max(0, Math.min(x, canvas.width - (width > 0 ? width : 1)));
        y = Math.max(0, Math.min(y, canvas.height - (height > 0 ? height : 1)));
        width = Math.max(1, Math.min(width, canvas.width - x));
        height = Math.max(1, Math.min(height, canvas.height - y));

        cropBox.style.left = `${x * scaleX}px`;
        cropBox.style.top = `${y * scaleY}px`;
        cropBox.style.width = `${width * scaleX}px`;
        cropBox.style.height = `${height * scaleY}px`;
      }

      function applyCrop() {
        if (!originalImg) {
          showMessage("Please upload an image first.");
          return;
        }
        showLoader(true);
        const x = parseInt(cropXInput.value);
        const y = parseInt(cropYInput.value);
        const width = parseInt(cropWidthInput.value);
        const height = parseInt(cropHeightInput.value);

        if (width <= 0 || height <= 0) {
          showMessage("Invalid crop dimensions.");
          showLoader(false);
          return;
        }

        const newCanvas = document.createElement("canvas");
        newCanvas.width = width;
        newCanvas.height = height;
        const newCtx = newCanvas.getContext("2d");
        newCtx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

        canvas.width = newCanvas.width;
        canvas.height = newCanvas.height;
        ctx.drawImage(newCanvas, 0, 0);

        saveHistory();
        cancelCrop(); // Exit crop mode
        showLoader(false);
        showMessage("Image cropped successfully!");
      }

      function applyResize() {
        if (!originalImg) {
          showMessage("Please upload an image first.");
          return;
        }
        showLoader(true);
        let width = parseInt(document.getElementById("resizeWidth").value);
        let height = parseInt(
          parseInt(document.getElementById("resizeHeight").value),
        );
        if (!width || width <= 0 || !height || height <= 0) {
          showMessage(
            "Invalid dimensions. Please enter valid width and height values.",
          );
          showLoader(false);
          return;
        }
        let temp = document.createElement("canvas");
        temp.width = width;
        temp.height = height;
        temp.getContext("2d").drawImage(canvas, 0, 0, width, height);
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(temp, 0, 0);
        saveHistory();
        showLoader(false);
        showMessage("Image resized successfully!");
      }

      document
        .getElementById("resizeWidth")
        .addEventListener("input", function () {
          if (keepRatioCheckbox.checked && originalImg) {
            let width = parseInt(this.value);
            let ratio = originalImg.width / originalImg.height;
            document.getElementById("resizeHeight").value = Math.round(
              width / ratio,
            );
          }
        });

      document
        .getElementById("resizeHeight")
        .addEventListener("input", function () {
          if (keepRatioCheckbox.checked && originalImg) {
            let height = parseInt(this.value);
            let ratio = originalImg.width / originalImg.height;
            document.getElementById("resizeWidth").value = Math.round(
              height * ratio,
            );
          }
        });

      function removeAndReplaceColor() {
        if (!originalImg) {
          showMessage("Please upload an image first.");
          return;
        }
        const removeColor = document.getElementById("removeColorPicker").value;
        const tolerance =
          parseInt(document.getElementById("removeColorTolerance").value) || 0;
        const rRemove = parseInt(removeColor.slice(1, 3), 16);
        const gRemove = parseInt(removeColor.slice(3, 5), 16);
        const bRemove = parseInt(removeColor.slice(5, 7), 16);
        const doReplace = replaceEnabledCheckbox.checked;

        showLoader(true);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        if (doReplace) {
          const replaceColor =
            document.getElementById("newBgColorPicker").value;
          const rReplace = parseInt(replaceColor.slice(1, 3), 16);
          const gReplace = parseInt(replaceColor.slice(3, 5), 16);
          const bReplace = parseInt(replaceColor.slice(5, 7), 16);

          for (let i = 0; i < data.length; i += 4) {
            const r = data[i],
              g = data[i + 1],
              b = data[i + 2];
            const distance = Math.sqrt(
              Math.pow(r - rRemove, 2) +
                Math.pow(g - gRemove, 2) +
                Math.pow(b - bRemove, 2),
            );
            if (distance <= tolerance) {
              data[i] = rReplace;
              data[i + 1] = gReplace;
              data[i + 2] = bReplace;
              data[i + 3] = 255;
            }
          }
        } else {
          // Option to remove the color and make it transparent
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i],
              g = data[i + 1],
              b = data[i + 2];
            const distance = Math.sqrt(
              Math.pow(r - rRemove, 2) +
                Math.pow(g - gRemove, 2) +
                Math.pow(b - bRemove, 2),
            );
            if (distance <= tolerance) {
              data[i + 3] = 0; // Set alpha to 0 for transparency
            }
          }
        }

        ctx.putImageData(imageData, 0, 0);
        saveHistory();
        setCheckerboard(!doReplace);
        showLoader(false);
        showMessage("Color operation applied successfully!");
      }

      async function downloadPDF() {
        if (!originalImg) {
          showMessage("Please upload an image first.");
          return;
        }
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();
        const imgData = canvas.toDataURL("image/png");
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();
        const canvasAspectRatio = canvas.width / canvas.height;
        let imgWidth = pdfWidth - 20;
        let imgHeight = imgWidth / canvasAspectRatio;
        if (imgHeight > pdfHeight - 20) {
          imgHeight = pdfHeight - 20;
          imgWidth = imgHeight * canvasAspectRatio;
        }
        const xOffset = (pdfWidth - imgWidth) / 2;
        const yOffset = (pdfHeight - imgHeight) / 2;
        pdf.addImage(imgData, "PNG", xOffset, yOffset, imgWidth, imgHeight);
        const name = document.getElementById("pdfName").value || "download.pdf";
        pdf.save(name);
        showMessage("Exporting to PDF...");
      }

      function exportImage() {
        if (!originalImg) {
          showMessage("Please upload an image first.");
          return;
        }
        const exportName =
          document.getElementById("exportName").value || "image";
        const exportFormat = document.getElementById("exportFormat").value;
        const quality = parseFloat(
          document.getElementById("exportQuality").value,
        );
        const mimeType = `image/${exportFormat}`;
        canvas.toBlob(
          (blob) => {
            if (!blob) {
              showMessage("Failed to export image. Try a different format.");
              return;
            }
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `${exportName}.${exportFormat}`;
            link.click();
          },
          mimeType,
          quality,
        );
        showMessage("Image exported successfully!");
      }

      function resetToOriginal() {
        if (!initialImageData) {
          showMessage("No image to reset.");
          return;
        }
        showLoader(true);
        canvas.width = initialImageData.width;
        canvas.height = initialImageData.height;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.putImageData(initialImageData, 0, 0);
        document.getElementById("resizeWidth").value = initialImageData.width;
        document.getElementById("resizeHeight").value = initialImageData.height;
        // Reset the checkerboard based on the original image type
        if (
          originalImg.src.startsWith("data:image/png") ||
          originalImg.src.startsWith("data:image/webp")
        ) {
          setCheckerboard(true);
        } else {
          setCheckerboard(false);
        }
        // Clear history when resetting
        history = [];
        historyIndex = -1;
        saveHistory();
        showLoader(false);
        showMessage("Image reset to original.");
      }

      function handleDrop(event) {
        event.preventDefault();
        const file = event.dataTransfer.files[0];
        if (file && file.type.startsWith("image/")) {
          showLoader(true);
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              if (file.type === "image/png" || file.type === "image/webp") {
                setCheckerboard(true);
              } else {
                setCheckerboard(false);
              }

              ctx.clearRect(0, 0, canvas.width, canvas.height);
              canvas.width = img.width;
              canvas.height = img.height;
              ctx.drawImage(img, 0, 0);
              originalImg = img;

              // Clear and save initial state to history
              history = [];
              historyIndex = -1;
              saveHistory();

              initialImageData = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height,
              );
              document.getElementById("resizeWidth").disabled = false;
              document.getElementById("resizeHeight").disabled = false;
              document.getElementById("keepRatio").disabled = false;
              document.getElementById("resizeButton").disabled = false;
              document.getElementById("resizeWidth").value = img.width;
              document.getElementById("resizeHeight").value = img.height;
              showLoader(false);
              showMessage("Image dropped and loaded!");
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        } else {
          showMessage("Please drop a valid image file.");
        }
      }

      function handleDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = "copy";
      }

      canvas.addEventListener("click", function (event) {
        if (!originalImg || isCropping) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (event.clientX - rect.left) * scaleX;
        const y = (event.clientY - rect.top) * scaleY;
        const pixel = ctx.getImageData(x, y, 1, 1).data;
        const r = pixel[0].toString(16).padStart(2, "0");
        const g = pixel[1].toString(16).padStart(2, "0");
        const b = pixel[2].toString(16).padStart(2, "0");
        const hexColor = `#${r}${g}${b}`;
        document.getElementById("removeColorPicker").value = hexColor;
        showMessage(`Color picked: ${hexColor}`);
      });
    </script>
  </body>
</html>
